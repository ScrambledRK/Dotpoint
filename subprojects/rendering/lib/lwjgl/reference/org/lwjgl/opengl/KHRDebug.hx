package org.lwjgl.opengl;

import java.StdTypes;
@:native("org.lwjgl.opengl.KHRDebug")
@:final
/**
 * Native bindings to the <a href="http://www.opengl.org/registry/specs/KHR/debug.txt">KHR_debug</a> extension.
 * 
 * <p>This extension allows the GL to notify applications when various events occur that may be useful during application development, debugging and
 * profiling.</p>
 * 
 * <p>These events are represented in the form of enumerable messages with a human-readable string representation. Examples of debug events include incorrect
 * use of the GL, warnings of undefined behavior, and performance warnings.</p>
 * 
 * <p>A message is uniquely identified by a source, a type and an implementation-dependent ID within the source and type pair.</p>
 * 
 * <p>A message's source identifies the origin of the message and can either describe components of the GL, the window system, third-party external sources
 * such as external debuggers, or even the application itself.</p>
 * 
 * <p>The type of the message roughly identifies the nature of the event that caused the message. Examples include errors, performance warnings, warnings
 * about undefined behavior or notifications identifying that the application is within a specific section of the application code.</p>
 * 
 * <p>A message's ID for a given source and type further distinguishes messages within namespaces. For example, an error caused by a negative parameter value
 * or an invalid internal texture format are both errors generated by the API, but would likely have different message IDs.</p>
 * 
 * <p>Each message is also assigned to a severity level that denotes roughly how "important" that message is in comparison to other messages across all
 * sources and types. For example, notification of a GL error would likely have a higher severity than a performance warning due to redundant state changes.</p>
 * 
 * <p>Furthermore, every message contains an implementation-dependent string representation that provides a useful description of the event.</p>
 * 
 * <p>Messages are communicated to the application through an application-defined callback function that is called by the GL implementation on each debug
 * message. The motivation for the callback routine is to free application developers from actively having to query whether a GL error, or any other
 * debuggable event has happened after each call to a GL function. With a callback, developers can keep their code free of debug checks, set breakpoints in
 * the callback function, and only have to react to messages as they occur. In situations where using a callback is not possible, a message log is also
 * provided that stores only copies of recent messages until they are actively queried.</p>
 * 
 * <p>To control the volume of debug output, messages can be disabled either individually by ID, or entire sets of messages can be turned off based on
 * combination of source and type, through the entire application code or only section of the code encapsulated in debug groups. A debug group may also be
 * used to annotate the command stream using descriptive texts.</p>
 * 
 * <p>This extension also defines debug markers, a mechanism for the OpenGL application to annotate the command stream with markers for discrete events.</p>
 * 
 * <p>When profiling or debugging an OpenGL application with a built-in or an external debugger or profiler, it is difficult to relate the commands within the
 * command stream to the elements of the scene or parts of the program code to which they correspond. Debug markers and debug groups help obviate this by
 * allowing applications to specify this link. For example, a debug marker can be used to identify the beginning of a frame in the command stream and a
 * debug group can encapsulate a specific command stream to identify a rendering pass. Debug groups also allow control of the debug outputs volume per
 * section of an application code providing an effective way to handle the massive amount of debug outputs that drivers can generate.</p>
 * 
 * <p>Some existing implementations of {@link ARBDebugOutput ARB_debug_output} only expose the ARB_debug_output extension string if the context was created with the debug
 * flag {GLX|WGL}_CONTEXT_DEBUG_BIT_ARB as specified in {GLX|WGL}_ARB_create_context. The behavior is not obvious when the functionality is brought into
 * the OpenGL core specification because the extension string and function entry points must always exist.</p>
 * 
 * <p>This extension modifies the existing ARB_debug_output extension to allow implementations to always have an empty message log. The specific messages
 * written to the message log or callback routines are already implementation defined, so this specification simply makes it explicit that it's fine for
 * there to be zero messages generated, even when a GL error occurs, which is useful if the context is non-debug.</p>
 * 
 * <p>Debug output can be enabled and disabled by changing the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state. It is implementation defined how much debug output is generated if the
 * context was created without the {@link #GL_CONTEXT_FLAG_DEBUG_BIT CONTEXT_FLAG_DEBUG_BIT} set. This is a new query bit added to the existing {@link GL30#GL_CONTEXT_FLAGS CONTEXT_FLAGS} state to specify whether the
 * context was created with debug enabled.</p>
 * 
 * <p>Finally, this extension defines a mechanism for OpenGL applications to label their objects (textures, buffers, shaders, etc.) with a descriptive string.</p>
 * 
 * <p>When profiling or debugging an OpenGL application within an external or built-in (debut output API) debugger or profiler it is difficult to identify
 * objects from their object names (integers).</p>
 * 
 * <p>Even when the object itself is viewed it can be problematic to differentiate between similar objects. Attaching a descriptive string, a label, to an
 * object obviates this difficulty.</p>
 * 
 * <p>The intended purpose of this extension is purely to improve the user experience within OpenGL development tools and application built-in profilers and
 * debuggers. This extension typically improves OpenGL programmers efficiency by allowing them to instantly detect issues and the reason for these issues
 * giving him more time to focus on adding new features to an OpenGL application.</p>
 * 
 * <p>Promoted to core in {@link GL43 OpenGL 4.3}.</p>
 */
extern class KHRDebug 
{
/** Tokens accepted by the {@code target} parameters of Enable, Disable, and IsEnabled.  */
	inline static public var GL_DEBUG_OUTPUT:Int = 37600;
/** Tokens accepted by the {@code target} parameters of Enable, Disable, and IsEnabled.  */
	inline static public var GL_DEBUG_OUTPUT_SYNCHRONOUS:Int = 33346;
/** Returned by GetIntegerv when {@code pname} is CONTEXT_FLAGS.  */
	inline static public var GL_CONTEXT_FLAG_DEBUG_BIT:Int = 2;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_MAX_DEBUG_MESSAGE_LENGTH:Int = 37187;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_MAX_DEBUG_LOGGED_MESSAGES:Int = 37188;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_DEBUG_LOGGED_MESSAGES:Int = 37189;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:Int = 33347;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_MAX_DEBUG_GROUP_STACK_DEPTH:Int = 33388;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_DEBUG_GROUP_STACK_DEPTH:Int = 33389;
/** Tokens accepted by the {@code value} parameters of GetBooleanv, GetIntegerv, GetFloatv, GetDoublev and GetInteger64v.  */
	inline static public var GL_MAX_LABEL_LENGTH:Int = 33512;
/** Tokens accepted by the {@code pname} parameter of GetPointerv.  */
	inline static public var GL_DEBUG_CALLBACK_FUNCTION:Int = 33348;
/** Tokens accepted by the {@code pname} parameter of GetPointerv.  */
	inline static public var GL_DEBUG_CALLBACK_USER_PARAM:Int = 33349;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_API:Int = 33350;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_WINDOW_SYSTEM:Int = 33351;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_SHADER_COMPILER:Int = 33352;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_THIRD_PARTY:Int = 33353;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_APPLICATION:Int = 33354;
/**
 * Tokens accepted or provided by the {@code source} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code sources} parameter
 * of GetDebugMessageLog (some commands restrict {@code source} to a subset of these parameters; see the specification body for details).
 */
	inline static public var GL_DEBUG_SOURCE_OTHER:Int = 33355;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_ERROR:Int = 33356;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:Int = 33357;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:Int = 33358;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_PORTABILITY:Int = 33359;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_PERFORMANCE:Int = 33360;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_OTHER:Int = 33361;
/**
 * Tokens accepted or provided by the {@code type} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC, and the {@code types} parameter of
 * GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_TYPE_MARKER:Int = 33384;
/** Tokens accepted or provided by the {@code type} parameters of DebugMessageControl and DEBUGPROC, and the {@code types} parameter of GetDebugMessageLog.  */
	inline static public var GL_DEBUG_TYPE_PUSH_GROUP:Int = 33385;
/** Tokens accepted or provided by the {@code type} parameters of DebugMessageControl and DEBUGPROC, and the {@code types} parameter of GetDebugMessageLog.  */
	inline static public var GL_DEBUG_TYPE_POP_GROUP:Int = 33386;
/**
 * Tokens accepted or provided by the {@code severity} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC callback functions, and the
 * {@code severities} parameter of GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_SEVERITY_HIGH:Int = 37190;
/**
 * Tokens accepted or provided by the {@code severity} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC callback functions, and the
 * {@code severities} parameter of GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_SEVERITY_MEDIUM:Int = 37191;
/**
 * Tokens accepted or provided by the {@code severity} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC callback functions, and the
 * {@code severities} parameter of GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_SEVERITY_LOW:Int = 37192;
/**
 * Tokens accepted or provided by the {@code severity} parameters of DebugMessageControl, DebugMessageInsert and DEBUGPROC callback functions, and the
 * {@code severities} parameter of GetDebugMessageLog.
 */
	inline static public var GL_DEBUG_SEVERITY_NOTIFICATION:Int = 33387;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_BUFFER:Int = 33504;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_SHADER:Int = 33505;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_PROGRAM:Int = 33506;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_QUERY:Int = 33507;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_PROGRAM_PIPELINE:Int = 33508;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_SAMPLER:Int = 33510;
/** Tokens accepted or provided by the {@code identifier} parameters of ObjectLabel and GetObjectLabel.  */
	inline static public var GL_DISPLAY_LIST:Int = 33511;
/** Function address.  */
	public var DebugMessageControl:haxe.Int64;
/** Function address.  */
	public var DebugMessageInsert:haxe.Int64;
/** Function address.  */
	public var DebugMessageCallback:haxe.Int64;
/** Function address.  */
	public var GetDebugMessageLog:haxe.Int64;
/** Function address.  */
	public var PushDebugGroup:haxe.Int64;
/** Function address.  */
	public var PopDebugGroup:haxe.Int64;
/** Function address.  */
	public var ObjectLabel:haxe.Int64;
/** Function address.  */
	public var GetObjectLabel:haxe.Int64;
/** Function address.  */
	public var ObjectPtrLabel:haxe.Int64;
/** Function address.  */
	public var GetObjectPtrLabel:haxe.Int64;
	public function new(provider:org.lwjgl.system.FunctionProvider):Void;
/** Unsafe version of {@link #glDebugMessageInsert DebugMessageInsert}  */
	static public function nglDebugMessageInsert(source:Int,type:Int,id:Int,severity:Int,length:Int,message:haxe.Int64):Void;
/** Unsafe version of {@link #glObjectLabel ObjectLabel}  */
	static public function nglObjectLabel(identifier:Int,name:Int,length:Int,label:haxe.Int64):Void;
/** CharSequence version of: {@link #glObjectPtrLabel ObjectPtrLabel}  */
/** Alternative version of: {@link #glObjectPtrLabel ObjectPtrLabel}  */
/**
 * Labels a sync object identified by a pointer.
 *
 * @param ptr    a pointer identifying a sync object
 * @param length the length of the label to be used for the object
 * @param label  a string containing the label to assign to the object
 */
	static public function glObjectPtrLabel(ptr:haxe.Int64,length:Int,label:java.nio.ByteBuffer):Void;
	@:overload(function (ptr:haxe.Int64,label:java.lang.CharSequence):Void {})
	@:overload(function (ptr:haxe.Int64,label:java.nio.ByteBuffer):Void {})
/** Single value version of: {@link #glDebugMessageControl DebugMessageControl}  */
/** Alternative version of: {@link #glDebugMessageControl DebugMessageControl}  */
/**
 * Controls the volume of debug output in the active debug group, by disabling specific or groups of messages.
 * 
 * <p>If {@code enabled} is {@link GL11#GL_TRUE TRUE}, the referenced subset of messages will be enabled. If {@link GL11#GL_FALSE FALSE}, then those messages will be disabled.</p>
 * 
 * <p>This command can reference different subsets of messages by first considering the set of all messages, and filtering out messages based on the following
 * ways:
 * <ul>
 * <li>If {@code source}, {@code type}, or {@code severity} is {@link GL11#GL_DONT_CARE DONT_CARE}, the messages from all sources, of all types, or of all severities are
 * referenced respectively.</li>
 * <li>When values other than {@link GL11#GL_DONT_CARE DONT_CARE} are specified, all messages whose source, type, or severity match the specified {@code source}, {@code type},
 * or {@code severity} respectively will be referenced.</li>
 * <li>If {@code count} is greater than zero, then {@code ids} is an array of {@code count} message IDs for the specified combination of {@code source} and
 * {@code type}. In this case, if {@code source} or {@code type} is {@link GL11#GL_DONT_CARE DONT_CARE}, or {@code severity} is not {@link GL11#GL_DONT_CARE DONT_CARE}, the error
 * {@link GL11#GL_INVALID_OPERATION INVALID_OPERATION} is generated.</li>
 * </ul></p>
 * 
 * <p>Unrecognized message IDs in {@code ids} are ignored. If {@code count} is zero, the value if {@code ids} is ignored.</p>
 * 
 * <p>Although messages are grouped into an implicit hierarchy by their sources and types, there is no explicit per-source, per-type or per-severity enabled
 * state. Instead, the enabled state is stored individually for each message. There is no difference between disabling all messages from one source in a
 * single call, and individually disabling all messages from that source using their types and IDs.</p>
 * 
 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled the GL operates the same as if messages of every {@code source}, {@code type} or {@code severity} are disabled.</p>
 *
 * @param source   the source of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_SOURCE_API DEBUG_SOURCE_API}, {@link #GL_DEBUG_SOURCE_WINDOW_SYSTEM DEBUG_SOURCE_WINDOW_SYSTEM}, {@link #GL_DEBUG_SOURCE_SHADER_COMPILER DEBUG_SOURCE_SHADER_COMPILER}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}, {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_OTHER DEBUG_SOURCE_OTHER}
 * @param type     the type of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_TYPE_ERROR DEBUG_TYPE_ERROR}, {@link #GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR DEBUG_TYPE_DEPRECATED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR DEBUG_TYPE_UNDEFINED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_PORTABILITY DEBUG_TYPE_PORTABILITY}, {@link #GL_DEBUG_TYPE_PERFORMANCE DEBUG_TYPE_PERFORMANCE}, {@link #GL_DEBUG_TYPE_OTHER DEBUG_TYPE_OTHER}, {@link #GL_DEBUG_TYPE_MARKER DEBUG_TYPE_MARKER}
 * @param severity the severity of debug messages to enable or disable. One of:<br>{@link #GL_DEBUG_SEVERITY_HIGH DEBUG_SEVERITY_HIGH}, {@link #GL_DEBUG_SEVERITY_MEDIUM DEBUG_SEVERITY_MEDIUM}, {@link #GL_DEBUG_SEVERITY_LOW DEBUG_SEVERITY_LOW}, {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}
 * @param count    the length of the array {@code ids}
 * @param ids      an array of unsigned integers containing the ids of the messages to enable or disable
 * @param enabled  whether the selected messages should be enabled or disabled
 */
	static public function glDebugMessageControl(source:Int,type:Int,severity:Int,count:Int,ids:java.nio.ByteBuffer,enabled:Bool):Void;
	@:overload(function (source:Int,type:Int,severity:Int,id:Int,enabled:Bool):Void {})
	@:overload(function (source:Int,type:Int,severity:Int,ids:java.nio.IntBuffer,enabled:Bool):Void {})
/** Unsafe version of {@link #glPushDebugGroup PushDebugGroup}  */
	static public function nglPushDebugGroup(source:Int,id:Int,length:Int,message:haxe.Int64):Void;
/** String return (w/ implicit max length) version of: {@link #glGetObjectLabel GetObjectLabel}  */
/** String return version of: {@link #glGetObjectLabel GetObjectLabel}  */
/** Alternative version of: {@link #glGetObjectLabel GetObjectLabel}  */
/**
 * Retrieves the label of a named object identified within a namespace.
 *
 * @param identifier the namespace from which the name of the object is allocated. One of:<br>{@link #GL_BUFFER BUFFER}, {@link #GL_SHADER SHADER}, {@link #GL_PROGRAM PROGRAM}, {@link #GL_QUERY QUERY}, {@link #GL_PROGRAM_PIPELINE PROGRAM_PIPELINE}, {@link #GL_SAMPLER SAMPLER}, {@link #GL_DISPLAY_LIST DISPLAY_LIST}, {@link GL11#GL_VERTEX_ARRAY VERTEX_ARRAY}, {@link GL11#GL_TEXTURE TEXTURE}, {@link GL30#GL_RENDERBUFFER RENDERBUFFER}, {@link GL30#GL_FRAMEBUFFER FRAMEBUFFER}, {@link GL40#GL_TRANSFORM_FEEDBACK TRANSFORM_FEEDBACK}
 * @param name       the name of the object whose label to retrieve
 * @param bufSize    the length of the buffer whose address is in {@code label}
 * @param length     the address of a variable to receive the length of the object label
 * @param label      a string that will receive the object label
 */
	static public function glGetObjectLabel(identifier:Int,name:Int,bufSize:Int,length:java.nio.ByteBuffer,label:java.nio.ByteBuffer):Void;
	@:overload(function (identifier:Int,name:Int):String {})
	@:overload(function (identifier:Int,name:Int,bufSize:Int):String {})
	@:overload(function (identifier:Int,name:Int,length:java.nio.IntBuffer,label:java.nio.ByteBuffer):Void {})
/**
 * Creates a {@link GLDebugMessageCallback} that delegates the callback to the specified functional interface.
 *
 * @param sam the delegation target
 *
 * @return the {@link GLDebugMessageCallback} instance
 */
	static public function GLDebugMessageCallback(sam:org.lwjgl.opengl.GLDebugMessageCallback_SAM):org.lwjgl.opengl.GLDebugMessageCallback;
/** CharSequence version of: {@link #glObjectLabel ObjectLabel}  */
/** Alternative version of: {@link #glObjectLabel ObjectLabel}  */
/**
 * Labels a named object identified within a namespace.
 *
 * @param identifier the namespace from which the name of the object is allocated. One of:<br>{@link #GL_BUFFER BUFFER}, {@link #GL_SHADER SHADER}, {@link #GL_PROGRAM PROGRAM}, {@link #GL_QUERY QUERY}, {@link #GL_PROGRAM_PIPELINE PROGRAM_PIPELINE}, {@link #GL_SAMPLER SAMPLER}, {@link #GL_DISPLAY_LIST DISPLAY_LIST}, {@link GL11#GL_VERTEX_ARRAY VERTEX_ARRAY}, {@link GL11#GL_TEXTURE TEXTURE}, {@link GL30#GL_RENDERBUFFER RENDERBUFFER}, {@link GL30#GL_FRAMEBUFFER FRAMEBUFFER}, {@link GL40#GL_TRANSFORM_FEEDBACK TRANSFORM_FEEDBACK}
 * @param name       the name of the object to label
 * @param length     the length of the label to be used for the object
 * @param label      a string containing the label to assign to the object
 */
	static public function glObjectLabel(identifier:Int,name:Int,length:Int,label:java.nio.ByteBuffer):Void;
	@:overload(function (identifier:Int,name:Int,label:java.lang.CharSequence):Void {})
	@:overload(function (identifier:Int,name:Int,label:java.nio.ByteBuffer):Void {})
/** Unsafe version of {@link #glGetObjectPtrLabel GetObjectPtrLabel}  */
	static public function nglGetObjectPtrLabel(ptr:haxe.Int64,bufSize:Int,length:haxe.Int64,label:haxe.Int64):Void;
/** Unsafe version of {@link #glDebugMessageControl DebugMessageControl}  */
	static public function nglDebugMessageControl(source:Int,type:Int,severity:Int,count:Int,ids:haxe.Int64,enabled:Bool):Void;
/** Unsafe version of {@link #glGetObjectLabel GetObjectLabel}  */
	static public function nglGetObjectLabel(identifier:Int,name:Int,bufSize:Int,length:haxe.Int64,label:haxe.Int64):Void;
/** Unsafe version of {@link #glGetDebugMessageLog GetDebugMessageLog}  */
	static public function nglGetDebugMessageLog(count:Int,bufsize:Int,sources:haxe.Int64,types:haxe.Int64,ids:haxe.Int64,severities:haxe.Int64,lengths:haxe.Int64,messageLog:haxe.Int64):Int;
/**
 * Specifies a callback to receive debugging messages from the GL.
 * 
 * <p>The function's prototype must follow the type definition of DEBUGPROC including its platform-dependent calling convention. Anything else will result in
 * undefined behavior. Only one debug callback can be specified for the current context, and further calls overwrite the previous callback. Specifying
 * {@code NULL} as the value of {@code callback} clears the current callback and disables message output through callbacks. Applications can provide
 * user-specified data through the pointer {@code userParam}. The context will store this pointer and will include it as one of the parameters in each call
 * to the callback function.</p>
 * 
 * <p>If the application has specified a callback function for receiving debug output, the implementation will call that function whenever any enabled message
 * is generated.  The source, type, ID, and severity of the message are specified by the DEBUGPROC parameters {@code source}, {@code type}, {@code id}, and
 * {@code severity}, respectively. The string representation of the message is stored in {@code message} and its length (excluding the null-terminator) is
 * stored in {@code length}. The parameter {@code userParam} is the user-specified parameter that was given when calling DebugMessageCallback.</p>
 * 
 * <p>Applications can query the current callback function and the current user-specified parameter by obtaining the values of {@link #GL_DEBUG_CALLBACK_FUNCTION DEBUG_CALLBACK_FUNCTION} and
 * {@link #GL_DEBUG_CALLBACK_USER_PARAM DEBUG_CALLBACK_USER_PARAM}, respectively.</p>
 * 
 * <p>Applications that specify a callback function must be aware of certain special conditions when executing code inside a callback when it is called by the
 * GL, regardless of the debug source.</p>
 * 
 * <p>The memory for {@code message} is owned and managed by the GL, and should only be considered valid for the duration of the function call.</p>
 * 
 * <p>The behavior of calling any GL or window system function from within the callback function is undefined and may lead to program termination.</p>
 * 
 * <p>Care must also be taken in securing debug callbacks for use with asynchronous debug output by multi-threaded GL implementations.</p>
 * 
 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled then the GL will not call the callback function.</p>
 *
 * @param callback  a callback function that will be called when a debug message is generated
 * @param userParam a user supplied pointer that will be passed on each invocation of {@code callback}
 */
	static public function glDebugMessageCallback(callback_:org.lwjgl.opengl.GLDebugMessageCallback,userParam:haxe.Int64):Void;
/**
 * Pops the active debug group. When a debug group is popped, the GL will also generate a debug output message describing its cause based on the
 * {@code message} string, the source {@code source}, and an ID {@code id} submitted to the associated {@link #glPushDebugGroup PushDebugGroup} command. {@link #GL_DEBUG_TYPE_PUSH_GROUP DEBUG_TYPE_PUSH_GROUP}
 * and {@link #GL_DEBUG_TYPE_POP_GROUP DEBUG_TYPE_POP_GROUP} share a single namespace for message {@code id}. {@code severity} has the value {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}. The {@code type}
 * has the value {@link #GL_DEBUG_TYPE_POP_GROUP DEBUG_TYPE_POP_GROUP}. Popping a debug group restores the debug output volume control of the parent debug group.
 * 
 * <p>Attempting to pop the default debug group off the stack generates a {@link GL11#GL_STACK_UNDERFLOW STACK_UNDERFLOW} error; pushing a debug group onto a stack containing
 * {@link #GL_MAX_DEBUG_GROUP_STACK_DEPTH MAX_DEBUG_GROUP_STACK_DEPTH} minus one elements will generate a {@link GL11#GL_STACK_OVERFLOW STACK_OVERFLOW} error.</p>
 */
	static public function glPopDebugGroup():Void;
/** Unsafe version of {@link #glObjectPtrLabel ObjectPtrLabel}  */
	static public function nglObjectPtrLabel(ptr:haxe.Int64,length:Int,label:haxe.Int64):Void;
/** String return (w/ implicit max length) version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel}  */
/** String return version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel}  */
/** Alternative version of: {@link #glGetObjectPtrLabel GetObjectPtrLabel}  */
/**
 * Retrieves the label of a sync object identified by a pointer.
 *
 * @param ptr     the name of the sync object whose label to retrieve
 * @param bufSize the length of the buffer whose address is in {@code label}
 * @param length  a variable to receive the length of the object label
 * @param label   a string that will receive the object label
 */
	static public function glGetObjectPtrLabel(ptr:haxe.Int64,bufSize:Int,length:java.nio.ByteBuffer,label:java.nio.ByteBuffer):Void;
	@:overload(function (ptr:haxe.Int64):String {})
	@:overload(function (ptr:haxe.Int64,bufSize:Int):String {})
	@:overload(function (ptr:haxe.Int64,length:java.nio.IntBuffer,label:java.nio.ByteBuffer):Void {})
/** Returns the {@link KHRDebug} instance for the current context.  */
	static public function getInstance():org.lwjgl.opengl.KHRDebug;
/** CharSequence version of: {@link #glDebugMessageInsert DebugMessageInsert}  */
/** Alternative version of: {@link #glDebugMessageInsert DebugMessageInsert}  */
/**
 * This function can be called by applications and third-party libraries to generate their own messages, such as ones containing timestamp information or
 * signals about specific render system events.
 * 
 * <p>The value of {@code id} specifies the ID for the message and {@code severity} indicates its severity level as defined by the caller. The string
 * {@code buf} contains the string representation of the message. The parameter {@code length} contains the number of characters in {@code buf}. If
 * {@code length} is negative, it is implied that {@code buf} contains a null terminated string. The error {@link GL11#GL_INVALID_VALUE INVALID_VALUE} will be generated if the
 * number of characters in {@code buf}, excluding the null terminator when {@code length} is negative, is not less than the value of
 * {@link #GL_MAX_DEBUG_MESSAGE_LENGTH MAX_DEBUG_MESSAGE_LENGTH}.</p>
 * 
 * <p>If the {@link #GL_DEBUG_OUTPUT DEBUG_OUTPUT} state is disabled calls to DebugMessageInsert are discarded and do not generate an error.</p>
 *
 * @param source   the source of the debug message to insert. One of:<br>{@link #GL_DEBUG_SOURCE_API DEBUG_SOURCE_API}, {@link #GL_DEBUG_SOURCE_WINDOW_SYSTEM DEBUG_SOURCE_WINDOW_SYSTEM}, {@link #GL_DEBUG_SOURCE_SHADER_COMPILER DEBUG_SOURCE_SHADER_COMPILER}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}, {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_OTHER DEBUG_SOURCE_OTHER}
 * @param type     the type of the debug message insert. One of:<br>{@link #GL_DEBUG_TYPE_ERROR DEBUG_TYPE_ERROR}, {@link #GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR DEBUG_TYPE_DEPRECATED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR DEBUG_TYPE_UNDEFINED_BEHAVIOR}, {@link #GL_DEBUG_TYPE_PORTABILITY DEBUG_TYPE_PORTABILITY}, {@link #GL_DEBUG_TYPE_PERFORMANCE DEBUG_TYPE_PERFORMANCE}, {@link #GL_DEBUG_TYPE_OTHER DEBUG_TYPE_OTHER}, {@link #GL_DEBUG_TYPE_MARKER DEBUG_TYPE_MARKER}
 * @param id       the user-supplied identifier of the message to insert. One of:<br>{@link #GL_DEBUG_SEVERITY_HIGH DEBUG_SEVERITY_HIGH}, {@link #GL_DEBUG_SEVERITY_MEDIUM DEBUG_SEVERITY_MEDIUM}, {@link #GL_DEBUG_SEVERITY_LOW DEBUG_SEVERITY_LOW}, {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}
 * @param severity the severity of the debug messages to insert
 * @param length   the length of the string contained in the character array whose address is given by {@code message}
 * @param message  a character array containing the message to insert
 */
	static public function glDebugMessageInsert(source:Int,type:Int,id:Int,severity:Int,length:Int,message:java.nio.ByteBuffer):Void;
	@:overload(function (source:Int,type:Int,id:Int,severity:Int,message:java.lang.CharSequence):Void {})
	@:overload(function (source:Int,type:Int,id:Int,severity:Int,message:java.nio.ByteBuffer):Void {})
/** CharSequence version of: {@link #glPushDebugGroup PushDebugGroup}  */
/** Alternative version of: {@link #glPushDebugGroup PushDebugGroup}  */
/**
 * Pushes a debug group described by the string {@code message} into the command stream. The value of {@code id} specifies the ID of messages generated.
 * The parameter {@code length} contains the number of characters in {@code message}. If {@code length} is negative, it is implied that {@code message}
 * contains a null terminated string. The message has the specified {@code source} and {@code id}, {@code type} {@link #GL_DEBUG_TYPE_PUSH_GROUP DEBUG_TYPE_PUSH_GROUP}, and
 * {@code severity} {@link #GL_DEBUG_SEVERITY_NOTIFICATION DEBUG_SEVERITY_NOTIFICATION}. The GL will put a new debug group on top of the debug group stack which inherits the control of the
 * volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any
 * additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.
 * 
 * <p>An {@link GL11#GL_INVALID_ENUM INVALID_ENUM} error is generated if the value of {@code source} is neither {@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION} nor {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}. An
 * {@link GL11#GL_INVALID_VALUE INVALID_VALUE} error is generated if {@code length} is negative and the number of characters in {@code message}, excluding the null-terminator, is
 * not less than the value of {@link #GL_MAX_DEBUG_MESSAGE_LENGTH MAX_DEBUG_MESSAGE_LENGTH}.</p>
 *
 * @param source  the source of the debug message. One of:<br>{@link #GL_DEBUG_SOURCE_APPLICATION DEBUG_SOURCE_APPLICATION}, {@link #GL_DEBUG_SOURCE_THIRD_PARTY DEBUG_SOURCE_THIRD_PARTY}
 * @param id      the identifier of the message
 * @param length  the length of the message to be sent to the debug output stream
 * @param message a string containing the message to be sent to the debug output stream
 */
	static public function glPushDebugGroup(source:Int,id:Int,length:Int,message:java.nio.ByteBuffer):Void;
	@:overload(function (source:Int,id:Int,message:java.lang.CharSequence):Void {})
	@:overload(function (source:Int,id:Int,message:java.nio.ByteBuffer):Void {})
/** Alternative version of: {@link #glGetDebugMessageLog GetDebugMessageLog}  */
/**
 * Retrieves messages from the debug message log.
 * 
 * <p>This function fetches a maximum of <count> messages from the message log, and will return the number of messages successfully fetched.</p>
 * 
 * <p>Messages will be fetched from the log in order of oldest to newest. Those messages that were fetched will be removed from the log.</p>
 * 
 * <p>The sources, types, severities, IDs, and string lengths of fetched messages will be stored in the application-provided arrays {@code sources},
 * {@code types}, {@code severities}, {@code ids}, and {@code lengths}, respectively. The application is responsible for allocating enough space for each
 * array to hold up to {@code count} elements. The string representations of all fetched messages are stored in the {@code messageLog} array. If multiple
 * messages are fetched, their strings are concatenated into the same {@code messageLog} array and will be separated by single null terminators. The last
 * string in the array will also be null-terminated. The maximum size of {@code messageLog}, including the space used by all null terminators, is given by
 * {@code bufSize}. If {@code bufSize} is less than zero and {@code messageLog} is not {@code NULL}, an {@link GL11#GL_INVALID_VALUE INVALID_VALUE} error will be generated. If a message's
 * string, including its null terminator, can not fully fit within the {@code messageLog} array's remaining space, then that message and any subsequent
 * messages will not be fetched and will remain in the log. The string lengths stored in the array {@code lengths} include the space for the null terminator of each string.</p>
 * 
 * <p>Any or all of the arrays {@code sources}, {@code types}, {@code ids}, {@code severities}, {@code lengths} and {@code messageLog} can also be null
 * pointers, which causes the attributes for such arrays to be discarded when messages are fetched, however those messages will still be removed from the
 * log. Thus to simply delete up to {@code count} messages from the message log while ignoring their attributes, the application can call the function with
 * null pointers for all attribute arrays.</p>
 * 
 * <p>If the context was created without the {@link #GL_CONTEXT_FLAG_DEBUG_BIT CONTEXT_FLAG_DEBUG_BIT} in the {@link GL30#GL_CONTEXT_FLAGS CONTEXT_FLAGS} state, then the GL can opt to never add messages to the message
 * log so GetDebugMessageLog will always return zero.</p>
 *
 * @param count      the number of debug messages to retrieve from the log
 * @param bufsize    the size of the buffer whose address is given by {@code messageLog}
 * @param sources    an array of variables to receive the sources of the retrieved messages
 * @param types      an array of variables to receive the types of the retrieved messages
 * @param ids        an array of unsigned integers to receive the ids of the retrieved messages
 * @param severities an array of variables to receive the severites of the retrieved messages
 * @param lengths    an array of variables to receive the lengths of the received messages
 * @param messageLog an array of characters that will receive the messages
 */
	static public function glGetDebugMessageLog(count:Int,bufsize:Int,sources:java.nio.ByteBuffer,types:java.nio.ByteBuffer,ids:java.nio.ByteBuffer,severities:java.nio.ByteBuffer,lengths:java.nio.ByteBuffer,messageLog:java.nio.ByteBuffer):Int;
	@:overload(function (count:Int,sources:java.nio.IntBuffer,types:java.nio.IntBuffer,ids:java.nio.IntBuffer,severities:java.nio.IntBuffer,lengths:java.nio.IntBuffer,messageLog:java.nio.ByteBuffer):Int {})

}
